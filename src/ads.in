#!/usr/bin/python
import sys, argparse, struct, os.path, datetime, uuid, re, pam
from time import sleep
from configparser import ConfigParser
import netifaces, ldap
from getpass import getpass, getuser
from subprocess import Popen, PIPE
from base64 import b64decode, b64encode
from ldap.modlist import addModlist as addlist
from ldap.modlist import modifyModlist as modlist
import pwd, grp
import samba
from samba.samdb import SamDB
from samba.param import LoadParm, default_path
from dns import resolver, reversename
from samba.net import Net
from samba.credentials import Credentials
from samba.dcerpc import nbt
from shutil import which
from samba import NTSTATUSError
from samba.netcmd.domain import cmd_domain_join, cmd_domain_provision
from samba.netcmd.dns import cmd_add_record
from samba.netcmd.user import cmd_user_list, cmd_user_add, cmd_user_add_unix_attrs, cmd_user_delete, cmd_user_password
from samba.netcmd.group import cmd_group_list, cmd_group_add, cmd_group_add_members, cmd_group_add_unix_attrs, cmd_group_delete
from samba.getopt import SambaOptions, CredentialsOptions
from optparse import OptionParser
from samba.logger import get_samba_logger
import psutil, os, signal
import socket
from enum import Enum
import tdb

nsswitch = '@NSSWITCHCONF@'
krb5_conf = '@KRB5CONF@'
winbindd = '@SBINDIR@/winbindd'
pam_auth_conf = '@PAM_D@/common-auth'
pam_password_conf = '@PAM_D@/common-password'
pam_session_conf = '@PAM_D@/common-session'
pam_module = '@LIBDIR@/security/pam_winbind.so'
winbind_conf = '@WINBINDCONF@'
net = '@BINDIR@/net'
samba_tool = '@BINDIR@/samba-tool'
samba = '@SBINDIR@/samba'
service = '@SBINDIR@/service'
systemctl = '@BINDIR@/systemctl'
debug_level = '0'

class Output(Enum):
    STDOUT = 0
    STDERR = 1
    PIPE = 2

class SambaToolFactory(object):
    def __init__(self, scmd, args=None, creds=None, stdout=Output.STDOUT, stderr=Output.STDERR):
        self.args = args

        parser = OptionParser()
        self.sambaopts = SambaOptions(parser)
        self.credopts = CredentialsOptions(parser)
        if creds:
            self.credopts.creds = creds
        elif self.args:
            self.credopts.creds = get_creds(self.args)
            self.credopts.ask_for_password = False
        self.credopts.machine_pass = False

        self.outlog = StringIO()
        self.errlog = StringIO()
        self.sobj = scmd(errf=sys.stderr if stderr == Output.STDERR else self.errlog)
        self.sobj.logger = get_samba_logger(name='ads',
                    stream=sys.stdout if stdout == Output.STDOUT else self.outlog,
                    verbose=(args.d > 0 if args and args.d is not None else False),
                    quiet=False, fmt='%(message)s')

    def set_realm(self, realm):
        self.sambaopts._set_realm(realm)

    def run(self, *args, **kwargs):
        try:
            self.sobj.run(sambaopts=self.sambaopts,
                          credopts=self.credopts,
                          *args, **kwargs)
            return (self.outlog.getvalue(), self.errlog.getvalue())
        except Exception as e:
            sys.stderr.write('%s exception:\n%s\n' % type(e).__name__, str(e))
            return -1

class SMBConfigParser(ConfigParser):
    def __init__(self, defaults=None, dict_type=None, allow_no_value=None):
        ConfigParser.__init__(self, defaults, dict_type, allow_no_value, interpolation=None)

    def _read(self, fp, fpname):
        cursect = None
        sectname = None
        optname = None
        e = None
        _SECT_TMPL = r"""\[(?P<header>[^]]+)\]"""
        _OPT_TMPL = r"""\s*(?P<option>.*?)\s*(?P<vi>=)\s*(?P<value>.*)$"""
        for lineno, line in enumerate(fp, start=1):
            if not line.strip() or line.strip()[0] == '#':
                continue
            if '#' in line:
                line = line.split('#')[0]
            mo = re.match(_SECT_TMPL, line)
            if mo:
                sectname = mo.group('header')
                if sectname in self._sections:
                    raise DuplicateSectionError(sectname, fpname, lineno)
                else:
                    cursect = self._dict()
                    cursect['__name__'] = sectname
                    self._sections[sectname] = cursect
                optname = None
            elif cursect is None:
                raise MissingSectionHeaderError(fpname, lineno, line)
            else:
                mo = re.match(_OPT_TMPL, line)
                if mo:
                    optname, vi, optval = mo.group('option', 'vi', 'value')
                    cursect[optname] = [optval.strip()]
                else:
                    e = self._handle_error(e, fpname, lineno, line)
        if e:
            raise e
        all_sections = [self._defaults]
        all_sections.extend(self._sections.values())
        for options in all_sections:
            for name, val in options.items():
                if isinstance(val, list):
                    options[name] = '\n'.join(val)

def stop_samba(services=None):
    if not services:
        services = ['samba', 'smbd', 'nmbd', 'winbindd']
    procs = [p for p in psutil.process_iter() if p.name() in services]
    for p in procs:
        os.kill(p.pid, signal.SIGKILL)

def clean_samba_db():
    lp = LoadParm()
    samba_dirs = [lp.state_path('lock'),
                  os.path.realpath(lp.state_path('.')),
                  os.path.realpath(lp.cache_path('.')),
                  os.path.realpath(lp.private_path('.'))]
    for topdir in samba_dirs:
        for root, dirs, files in os.walk(topdir):
            for fname in files:
                if fname.endswith('.tdb') or fname.endswith('.ldb'):
                    os.remove(os.path.join(root, fname))

samba_version = None
def get_samba_version():
    global samba_version
    if not samba_version:
        samba_version = re.findall('\d+\.\d+\.\d', samba.version)[0]
    return samba_version

def get_default_realm_int():
    lp = LoadParm()
    lp.load_default()
    return lp.get('realm')

default_realm = None
def get_default_realm():
    global default_realm
    if not default_realm:
        default_realm = get_default_realm_int()
    return default_realm

def get_netbios_name(creds, realm):
    l = ldap_open(realm, creds)

    results = l.search_s('CN=Partitions,CN=Configuration,%s' % realm_to_dn(realm), ldap.SCOPE_SUBTREE, '(netbiosname=*)', [])
    return results[0][1]['cn'][-1] if results and len(results) > 0 and len(results[0]) > 1 and 'cn' in results[0][1] and len(results[0][1]['cn']) > 0 else ''

def user_list(creds, debug_level):
    ulist = SambaToolFactory(cmd_user_list, creds=creds, stdout=Output.PIPE)
    return ulist.run()[0].strip().split('\n')

def group_list(creds, debug_level):
    glist = SambaToolFactory(cmd_group_list, creds=creds, stdout=Output.PIPE)
    return glist.run()[0].strip().split('\n')

def getpwnam(user):
    try:
        return ':'.join([str(i) for i in pwd.getpwnam(user)])
    except KeyError:
        return ''

def getgrnam(group):
    try:
        g = grp.getgrnam(group)
        return '%s:x:%d:%s' % (group, g.gr_gid, ','.join(g.gr_mem))
    except KeyError:
        return group

def getpwent(creds, debug_level):
    ulist = []
    for d in pwd.getpwall():
        ulist.append(':'.join([str(i) for i in d]))
    for u in user_list(creds, debug_level):
        ulist.append(getpwnam(u))
    return ulist

def getgrent(creds, debug_level):
    for d in grp.getgrall():
        print(':'.join([str(i) for i in d[:-1]])+':'+','.join(d.gr_mem))
    for g in group_list(creds, debug_level):
        print(getgrnam(g))

def get_creds(args):
    creds = Credentials()
    if args.u:
        creds.parse_string(args.u)
    else:
        creds.parse_string(getuser())
    if args.w:
        creds.set_password(args.w)
    else:
        creds.set_password(getpass("%s's Password: " % creds.get_username()))
    return creds

def pam_conv(auth, query_list):
    resp = []
    for (query, type) in query_list:
        # Never echo
        if type == PAM.PAM_PROMPT_ECHO_ON or PAM.PAM_PROMPT_ECHO_OFF:
            resp.append((getpass(query), 0))
        else:
            print(query)
            resp.append(('', 0))
    return resp

def ldap_posix_user(user, container):
    l = ldap_open(get_default_realm(), creds)
    results = l.search_s(container, ldap.SCOPE_SUBTREE, '(cn=%s)' % args.object, ['sAMAccountName', 'uidNumber', 'gidNumber', 'gecos', 'homeDirectory', 'loginShell'])
    if len(results) == 1:
        result = results[0][1]
        data = '%s:x' % result['sAMAccountName'][-1]
        for key in ['uidNumber', 'gidNumber', 'gecos', 'homeDirectory', 'loginShell']:
            arg = result[key][-1] if key in result.keys() else ''
            data += ':%s' % arg
        return data

def ldap_posix_pwent(container):
    ulist = []
    for u in user_list(creds, debug_level):
        ulist.append(ldap_posix_user(u, container))
    return ulist

def nss_getpwnam(args):
    if args.direct:
        pw = ldap_posix_user(args.object, user_container())
    else:
        realm = get_default_realm()
        pw = getpwnam(args.object)
        if not pw and not args.object.lower().endswith(realm.lower()) and not args.object.lower().startswith(realm.lower()):
            pw = getpwnam('%s@%s' % (args.object, realm))
    if pw:
        print(pw)

def nss_getpwuid(args):
    pw = getpwnam(args.object)
    if pw:
        print(pw)

def nss_getgrnam_getgrid(args):
    gr = getgrnam(args.object)
    realm = get_default_realm()
    if not gr and not args.object.lower().endswith(realm.lower()) and not args.object.lower().startswith(realm.lower()):
        gr = getgrnam('%s@%s' % (args.object, realm))
    if gr:
        print(gr)

def nss_getpwent(args):
    global debug_level
    creds = get_creds(args)
    if 'direct' in args and args.direct:
        ulist = ldap_posix_pwent(user_container())
    else:
        ulist = getpwent(creds, debug_level)
    for pw in ulist:
        if pw and pw.strip():
            print(pw)

def nss_getgrent(args):
    global debug_level
    creds = get_creds(args)
    getgrent(creds, debug_level)

def create_user(args):
    unix_attrs = {}
    if args.i:
        data = args.i.split(':')
        if len(data) != 7:
            sys.stderr.write('Invalid unix attrs initializer string')
            return -1
        unix_attrs['uid'] = data[0]
        if not args.e:
            unix_attris['uid_number'] = data[2]
        else:
            uid_number = data[2]
        unix_attrs['gid_number'] = data[3]
        unix_attrs['gecos'] = data[4]
        unix_attrs['unix_home'] = data[5]
        unix_attrs['login_shell'] = data[6]
    if not args.e:
        uadd = SambaToolFactory(cmd_user_add, args)
        uadd.run(args.object, password=new_user_pass, **unix_attrs)
    else:
        uunix_attrs = SambaToolFactory(cmd_user_add_unix_attrs, args)
        uadd.run(args.object, uid_number, **unix_attrs)

def create_group(args):
    unix_attrs = {}
    if args.i:
        data = args.i.split(':')
        if len(data) != 4:
            sys.stderr.write('Invalid unix attrs initializer string')
            return -1
        unix_attrs['gid_number'] = data[2]
    if not args.e:
        gadd = SambaToolFactory(cmd_group_add, args)
        gadd.run(args.object, **unix_attrs)
    elif 'gid_number' in unix_attrs:
        gunix_attrs = SambaToolFactory(cmd_group_add_unix_attrs, args)
        gunix_attrs.run(args.object, unix_attrs['gid_number'])

def delete_user(args):
    delu = SambaToolFactory(cmd_user_delete, args)
    delu.run(args.object)

def delete_group(args):
    delg = SambaToolFactory(cmd_group_delete, args)
    delg.run(args.object)

def user_checklogin(args):
    p = pam.pam()
    p.authenticate(args.user, getpass())
    if p.code == 0:
        print('Authentication succeeded')
    else:
        print('Authentication failed, reason: %s' % p.reason)
    return p.code

def passwd(args):
    if args.r:
        password = samba.generate_random_password(8, 20)
    else:
        password = None
    while True:
        if password is not None and password != '':
            break
        password = getpass("New Password: ")
        passwordverify = getpass("Retype Password: ")
        if not password == passwordverify:
            password = None
            print("Sorry, passwords do not match.")
    creds = get_creds(args)
    net = Net(creds)
    if args.object:
        net.set_password(args.object, get_default_realm(), password)
    else:
        net.change_password(password)
    if args.o:
        print(password)

# http://stackoverflow.com/questions/33188413/python-code-to-convert-from-objectsid-to-sid-representation
def convert_objsid_to_sidstr(binary):
    version = struct.unpack('B', binary[0])[0]
    # I do not know how to treat version != 1 (it does not exist yet)
    assert version == 1, version
    length = struct.unpack('B', binary[1])[0]
    authority = struct.unpack('>Q', '\x00\x00' + binary[2:8])[0]
    string = 'S-%d-%d' % (version, authority)
    binary = binary[8:]
    assert len(binary) == 4 * length
    for i in xrange(length):
        value = struct.unpack('<L', binary[4*i:4*(i+1)])[0]
        string += '-%d' % (value)
    return string

def realm_to_dn(realm):
    return ','.join(['dc=%s' % part for part in realm.split('.')])

def __validate_dom(dom):
    global cldap_ret
    net = Net(Credentials())
    cldap_ret = net.finddc(domain=dom, flags=(nbt.NBT_SERVER_LDAP | nbt.NBT_SERVER_DS))
    return cldap_ret.dns_domain if cldap_ret else None

def parse_username(username, domain=''):
    dom, user = (domain, username)
    if '\\' in username:
        dom, user = username.split('\\')
    elif '@' in username:
        user, dom = username.split('@')
    return dom, user

def __format_username(username, realm):
    dom, user = parse_username(username, realm)
    cldap_dom = __validate_dom(dom)
    dom = cldap_dom if dom else dom
    return '%s@%s' % (user, dom.upper())

ldap_open_connections = {}
def ldap_open(realm, creds):
    global ldap_open_connections
    key = '%s:%s' % (realm, creds.get_username())
    if key not in ldap_open_connections.keys():
        lp = LoadParm()
        lp.load_default()
        l = SamDB(url="ldap://%s" % realm,
                  session_info=system_session(),
                  credentials=creds, lp=lp)
        ldap_open_connections[key] = l
    return ldap_open_connections[key]

wkguiduc = 'A9D1CA15768811D1ADED00C04FD8D5CD'
uc = None
def user_container():
    global uc, wkguiduc
    if not uc:
        creds = get_creds(args)
        l = ldap_open(get_default_realm(), creds)
        results = l.search_s('<WKGUID=%s,%s>' % (wkguiduc, realm_to_dn(get_default_realm())), ldap.SCOPE_SUBTREE, '(objectClass=container)', ['distinguishedName'])
        uc = results[0][1]['distinguishedName'][-1]
    return uc

def print_ldap_object(obj, sidstr):
    for key in obj.keys():
        if key in ['logonHours', 'objectGUID', 'objectSid']:
            if key == 'objectSid' and sidstr:
                obj[key] = [convert_objsid_to_sidstr(o) for o in obj[key]]
            else:
                obj[key] = [b64encode(o) for o in obj[key]]
            for ob in obj[key]:
                print('%s:: %s' % (key, ob))
        else:
            for ob in obj[key]:
                print('%s: %s' % (key, ob))

def attrs(args):
    global debug_level
    if args.object:
        creds = get_creds(args)
        l = ldap_open(get_default_realm(), creds)
        container = args.c
        if not container:
            container = user_container()
        if debug_level != '0':
            print('ldapsearch', '-LLL', '-x', '-h', get_default_realm(), '-D', '%s@%s' % (admin, get_default_realm()), '-W', '-b', container, '"(cn=%s)"' % args.object, ' '.join(args.attributes))
        results = l.search_s(container, ldap.SCOPE_SUBTREE, '(cn=%s)' % args.object, args.attributes)
        for result in results:
            print_ldap_object(result[1], args.b)
            print()
    else:
        args.help_func()

def getdn(cn, container=None):
    creds = get_creds(args)
    l = ldap_open(get_default_realm(), creds)
    if not container:
        container = user_container()
    results = l.search_s(container, ldap.SCOPE_SUBTREE, '(cn=%s)' % cn, ['distinguishedName'])
    return results[0][1]['distinguishedName'][-1]

def setattrs(args):
    global debug_level
    creds = get_creds(args)
    l = ldap_open(get_default_realm(), creds)
    dn = getdn(args.object)
    ldif_old = {args.attribute: ['']}
    ldif = {args.attribute: [args.value]}
    try:
        l.modify_s(dn, modlist(ldif_old, ldif))
    except ldap.NO_SUCH_ATTRIBUTE:
        l.modify_s(dn, modlist({}, ldif))

def timesync(args):
    if args.s:
        Popen(['service', 'ntpd', 'stop']).wait()
        Popen(['/usr/sbin/ntpdate', args.s]).wait()
        Popen(['service', 'ntpd', 'start']).wait()

def config_ntp(servers):
    ntp_conf = '/etc/ntp.conf'
    if not os.path.exists(ntp_conf):
        sys.stderr.write('ntp not found. Package install required.\nzypper in ntp\n')
        sys.exit(1)

    # stop the ntp service
    Popen(['service', 'ntpd', 'stop']).wait()

    config = ''
    for line in open(ntp_conf):
        if line.strip() and line.strip().split()[0] != 'server': # throw out old server list
            config += line
    for server in servers:
        config += '\nserver %s\n' % server
    of = open(ntp_conf, 'w')
    of.write(config)

    # tell ntp to update the time
    Popen(['/usr/sbin/ntpdate', servers[0]]).wait()

    # restart ntp
    Popen(['service', 'ntpd', 'start']).wait()

def config_smb_conf(creds, domain, autogen=False, server=False):
    smb_conf = default_path()
    conf = SMBConfigParser()
    if os.path.exists(smb_conf):
        conf.read(smb_conf)
    if 'global' not in conf.sections():
        conf.add_section('global')
    if not server:
        netbios = get_netbios_name(creds, domain)
        conf.set('global', 'security', 'ads')
        conf.set('global', 'workgroup', domain.split('.')[0].upper())
        conf.set('global', 'realm', domain.upper())
        conf.set('global', 'log file', '/var/log/samba/%m.log')
        conf.set('global', 'log level', '1')
        conf.set('global', 'passdb backend', 'tdbsam')
        conf.set('global', 'map to guest', 'Bad User')
        conf.set('global', 'logon path', '\\\\%L\\profiles\\.msprofile')
        conf.set('global', 'logon home', '\\\\%L\\%U\\.9xprofile')
        conf.set('global', 'logon drive', 'P:')
        conf.set('global', 'usershare allow guests', 'yes')
        conf.set('global', 'winbind offline logon', 'yes')
        if autogen:
            conf.set('global', 'template shell', '/bin/bash')
            conf.set('global', 'template homedir', '/home/%D/%U')
            conf.set('global', 'idmap config * : backend', 'tdb')
            conf.set('global', 'idmap config * : range', '2000-3999')
            conf.set('global', 'idmap config %s : backend' % netbios, 'rid')
            conf.set('global', 'idmap config %s : range' % netbios, '4000-99999')
            if float(get_samba_version()[:3]) >= 4.6:
                conf.set('global', 'idmap config *:unix_nss_info', 'no')
            else:
                conf.set('global', 'winbind nss info', 'template')
        else:
            conf.set('global', 'idmap config *:backend', 'autorid')
            conf.set('global', 'idmap config *:range', '2000-3999')
            conf.set('global', 'idmap config %s:backend' % netbios, 'ad')
            conf.set('global', 'idmap config %s:schema_mode' % netbios, 'rfc2307')
            conf.set('global', 'idmap config %s:range' % netbios, '4000-99999')
            if float(get_samba_version()[:3]) >= 4.6:
                conf.set('global', 'idmap config %s:unix_nss_info' % netbios, 'yes')
            else:
                conf.set('global', 'winbind nss info', 'rfc2307')
    else:
        conf.set('global', 'winbind nss info', 'template')
        conf.set('global', 'template shell', '/bin/bash')
        conf.set('global', 'template homedir', '/home/%D/%U')
    of = open(smb_conf, 'w')
    conf.write(of)
    of.close()

def config_winbind_conf():
    global winbind_conf
    conf = SMBConfigParser()
    if os.path.exists(winbind_conf):
        conf.read(winbind_conf)
    if 'global' not in conf.sections():
        conf.add_section('global')
    conf.set('global', 'cached_login', 'yes')
    conf.set('global', 'krb5_auth', 'yes')
    conf.set('global', 'krb5_ccache_type', 'FILE')
    conf.set('global', 'warn_pwd_expire', '14')
    conf.set('global', 'mkhomedir', 'yes')
    of = open(winbind_conf, 'w')
    conf.write(of)
    of.close()

def follow_symlinks(files):
    for name in files:
        if os.path.exists(name) and os.path.islink(name):
            print('%s links to %s' % (name, os.path.realpath(name)))

def configure_nsswitch_conf():
    global nsswitch
    try:
        conf = ''
        for line in open(nsswitch):
            fore = line.strip().split(':')[0]
            if (fore == 'passwd' or fore == 'group') and 'winbind' not in line:
                conf += '%s winbind\n' % line.replace('[NOTFOUND=return]', '').rstrip()
            else:
                conf += line
        of = open(nsswitch, 'w')
        of.write(conf)
    except IOError:
        sys.stderr.write('Configure nsswitch failed, filename \'%s\' not found\n' % nsswitch)

def configure_nss(args):
    if not os.path.exists('@LIBDIR@/libnss_winbind.so'):
        if os.path.exists('@LIBDIR@/libnss_winbind.so.2'):
            os.symlink('@LIBDIR@/libnss_winbind.so.2', '@LIBDIR@/libnss_winbind.so')
            follow_symlinks(['@LIBDIR@/libnss_winbind.so'])
            configure_nsswitch_conf()
        else:
            sys.stderr.write('Cannot find @LIBDIR@/libnss_winbind.so, check that you\'ve installed the library\n')
    else:
        follow_symlinks(['@LIBDIR@/libnss_winbind.so'])
        configure_nsswitch_conf()

def unconfigure_nss(args):
    global nsswitch
    try:
        conf = ''
        for line in open(nsswitch):
            fore = line.strip().split(':')[0]
            if (fore == 'passwd' or fore == 'group') and 'winbind' in line:
                conf += line.replace('winbind', '')
            else:
                conf += line
        of = open(nsswitch, 'w')
        of.write(conf)
    except IOError:
        sys.stderr.write('Unconfigure nsswitch failed, filename \'%s\' not found\n' % nsswitch)

def configure_pam_auth(pam_conf):
    global pam_module
    conf = ''
    for line in open(pam_conf):
        if 'pam_unix.so' in line and line.split()[0] == 'auth':
            conf += 'auth\tsufficient\tpam_unix.so try_first_pass\n'
            conf += 'auth\trequired\t%s use_first_pass\n' % pam_module
        elif not pam_module.split('/')[-1] in line:
            conf += line
    of = open(pam_conf, 'w')
    of.write(conf)

def configure_pam_password(pam_conf):
    global pam_module
    conf = ''
    first_line = True
    for line in open(pam_conf):
        if line.strip()[0] != '#' and first_line:
            conf += 'password\tsufficient\t%s\n' % pam_module
            first_line = False
        elif not pam_module.split('/')[-1] in line:
            conf += line
    of = open(pam_conf, 'w')
    of.write(conf)

def configure_pam_session(pam_conf):
    conf = ''
    for line in open(pam_conf):
        if 'session' in line and 'pam_unix.so' in line:
            conf += 'session\toptional\tpam_mkhomedir.so\n'
        elif not 'pam_mkhomedir.so' in line:
            conf += line
    of = open(pam_conf, 'w')
    of.write(conf)

def configure_pam(args):
    global pam_auth_conf, pam_password_conf, pam_module, pam_session_conf
    if not os.path.exists(pam_module):
        if os.path.exists('/lib64/security/pam_winbind.so'):
            if not os.path.exists('@LIBDIR@/security'):
                os.mkdir('@LIBDIR@/security')
            os.symlink('/lib64/security/pam_winbind.so', pam_module)
            configure_pam_auth(pam_auth_conf)
            configure_pam_password(pam_password_conf)
            configure_pam_session(pam_session_conf)
            follow_symlinks([pam_module])
        else:
            sys.stderr.write('Cannot find @LIBDIR@/security/pam_winbind.so, check that you\'ve installed the library\n')
    else:
        configure_pam_auth(pam_auth_conf)
        configure_pam_password(pam_password_conf)
        configure_pam_session(pam_session_conf)
        follow_symlinks([pam_module])

def unconfigure_pam_password():
    global pam_module, pam_password_conf
    conf = ''
    for line in open(pam_password_conf):
        if not pam_module.split('/')[-1] in line:
            conf += line
    of = open(pam_password_conf, 'w')
    of.write(conf)

def unconfigure_pam_auth():
    global pam_module, pam_auth_conf
    conf = ''
    first_line = True
    for line in open(pam_auth_conf):
        if 'pam_unix.so' in line and line.split()[0] == 'auth':
            conf += 'auth\trequired\tpam_unix.so try_first_pass\n'
        elif not pam_module.split('/')[-1] in line:
            conf += line
    of = open(pam_auth_conf, 'w')
    of.write(conf)

def unconfigure_pam_session():
    global pam_session_conf
    conf = ''
    for line in open(pam_session_conf):
        if not 'pam_mkhomedir.so' in line:
            conf += line
    of = open(pam_session_conf, 'w')
    of.write(conf)

def unconfigure_pam(args):
    unconfigure_pam_auth()
    unconfigure_pam_password()
    unconfigure_pam_session()

def configure(args):
    configure_pam(args)
    configure_nss(args)

def unconfigure(args):
    unconfigure_pam(args)
    unconfigure_nss(args)

def ip_addrs():
    ifaces = [netifaces.ifaddresses(interface) for interface in netifaces.interfaces()]
    return [data[2][0]['addr'] for data in ifaces if len(data)>2 and len(data[2])>0 and 'addr' in data[2][0] and data[2][0]['addr'] != '127.0.0.1']

def update_hostname(hostname, domain):
    # Retrieve the current hostname if one was specified
    shortname = None
    if not hostname:
        hostname = socket.gethostname()
    if not domain.lower() in hostname:
        shortname = hostname
        hostname = '%s.%s\n' % (hostname, domain)
    else:
        shortname = hostname.split('.')[0]

    # Update the /etc/hostname file
    hf = open('/etc/hostname', 'w')
    hf.write('%s' % hostname)

    # Update the in-memory hostname
    socket.sethostname(hostname)

    # Add an entry to /etc/hosts so we can resolve our own name
    hosts = '/etc/hosts'
    ips = ip_addrs()
    conf = ''
    for line in open(hosts):
        if hostname not in line:
            conf += line
    conf = conf.strip()
    conf += '\n'
    # Only the last one is used, may need to be manually configured
    for ip in ips:
        conf += '%s\t%s %s\n' % (ip, hostname, shortname)
    of = open(hosts, 'w')
    of.write(conf)

    return (hostname, shortname)

def remove_hosts_config():
    hostname = Popen(['hostname'], stdout=PIPE).communicate()[0].strip().decode('utf-8')
    hosts = '/etc/hosts'
    conf = ''
    for line in open(hosts):
        if hostname not in line:
            conf += line
    of = open(hosts, 'w')
    of.write(conf)

def krb5_basic_conf(domain):
    global krb5_conf
    kof = open(krb5_conf, 'w')
    kof.write('[libdefaults]\n')
    kof.write('\tdns_lookup_realm = false\n')
    kof.write('\tdns_lookup_kdc = true\n')
    kof.write('\tdefault_realm = %s\n' % domain)

def config_krb5_conf(domain, server):
    global krb5_conf
    kof = open(krb5_conf, 'w')
    kof.write('[libdefaults]\n')
    kof.write('\tdefault_realm = %s\n' % domain)
    kof.write('\tclockskew = 300\n')
    kof.write('\tticket_lifetime = 1d\n')
    kof.write('\tforwardable = true\n')
    kof.write('\tproxiable = true\n')
    kof.write('\tdns_lookup_realm = true\n')
    kof.write('\tdns_lookup_kdc = true\n')
    kof.write('\tudp_preference_limit = 1\n') # disable UDP packets
    kof.write('\n\n[realms]\n')
    kof.write('\t%s = {\n\t\tkdc = %s\n\t\tadmin_server = %s\n\t\tdefault_domain = %s\n\t}\n' % (domain, server, server, domain))

def list_servers(domain):
    return [str(resolver.query(reversename.from_address(r.address),"PTR")[0])[:-1] for r in resolver.query(domain, 'A')]

def start_enable_service(name, binpath):
    global service, systemctl
    if os.path.exists(systemctl):
        Popen([systemctl, 'enable', name], stdout=PIPE, stderr=PIPE).wait()
        Popen([systemctl, 'daemon-reload'], stdout=PIPE, stderr=PIPE).wait()
        if Popen([systemctl, 'restart', name], stdout=PIPE, stderr=PIPE).wait() == 0:
            return
    if os.path.exists(service):
        if Popen([service, name, 'restart'], stdout=PIPE, stderr=PIPE).wait() == 0:
            return
    if os.path.exists(binpath):
        if Popen([binpath, '-d', debug_level, '--configfile=%s' % default_path(), '-D'], stdout=PIPE, stderr=PIPE).wait() == 0:
            return
    return -1

def stop_disable_service(name):
    if which('systemctl'):
        Popen(['systemctl', 'stop', name], stdout=PIPE, stderr=PIPE).wait()
        if Popen(['systemctl', 'disable', name], stdout=PIPE, stderr=PIPE).wait() == 0:
            return
    stop_samba(name)

def stash_config():
    global krb5_conf
    # Stash the old smb.conf
    if os.path.exists(default_path()):
        smb_conf = default_path()
        now = datetime.datetime.now()
        new_smb_conf = '%s.%s' % (smb_conf, now.strftime('%b-%d-%Y_%I:%M%p'))
        print('Stashing smb.conf to %s...' % new_smb_conf)
        os.rename(smb_conf, new_smb_conf)
    # Stash any old krb5.conf
    if os.path.exists(krb5_conf):
        now = datetime.datetime.now()
        new_krb5_conf = '%s.%s' % (krb5_conf, now.strftime('%b-%d-%Y_%I:%M%p'))
        print('Stashing krb5.conf to %s...' % new_krb5_conf)
        os.rename(krb5_conf, new_krb5_conf)

def start_samba():
    global samba
    start_enable_service('samba', samba)

    # Make sure winbindd started also
    ret = Popen(['ps ax | egrep "winbindd" | grep -v grep'], shell=True, stdout=PIPE).wait()
    if ret != 0:
        # If winbindd failed to start, try fixing it
        stop_samba()

        # Try again
        ret = start_enable_service('samba', samba)

    return ret

def options(args):
    parser = OptionParser()
    sambaopts = SambaOptions(parser)
    credopts = CredentialsOptions(parser)
    if args.u:
        credopts.creds.parse_string(args.u)
    if args.w:
        credopts.creds.set_password(args.w)
        credopts.ask_for_password = False
    else:
        credopts.ask_for_password = True
    credopts.machine_pass = False
    return sambaopts, credopts

def join(args):
    if getuser() != 'root':
        sys.stderr.write('ads join must be run as root\n')
        sys.exit(1)
    creds = get_creds(args)

    # Set the default realm, else kinit will fail
    default_realm = args.domain

    stop_samba()
    stop_disable_service('nscd')

    server = None
    if not args.servers:
        args.servers = list_servers(args.domain)
    server = args.servers[-1]

    stash_config()

    # configure kerberos
    print('Configuring kerberos...')
    config_krb5_conf(args.domain.upper(), server.upper())

    # Configure ntp
    print('Adding ntp servers and time syncing with AD...')
    if args.servers:
        config_ntp(args.servers)
    else:
        config_ntp([server])

    # Update hostname
    print('Updating hostname...')
    hostname = update_hostname(args.n, args.domain)

    join = SambaToolFactory(cmd_domain_join, args, creds)
    if not hasattr(args, 'domain_controller') or not args.domain_controller:
        # configure smb.conf
        print('Configuring smb.conf...')
        config_smb_conf(creds, args.domain, autogen=args.autogen_posix_attrs)

        # configure pam_winbind.conf
        print('Configuring pam_winbind.conf...')
        config_winbind_conf()

        # net ads join the domain
        print('Joining the domain...')
        ret = join.run(domain=args.domain, role='MEMBER')
        if ret == -1:
            return ret

        # start winbindd
        sys.stdout.write('Starting winbindd... ')
        ret = start_enable_service('winbindd', winbindd)
        if ret != 0:
            sys.stdout.write('failed\n')
        else:
            sys.stdout.write('ok\n')
    else:
        if not os.path.exists(samba_tool):
            sys.stderr.write('samba-ad-dc is not installed\n')
            return 1

        # Cleanup old samba database files
        clean_samba_db()

        # samba-tool domain join
        print('Joining the domain as a Domain Controller...')
        ret = join.run(domain=args.domain, role='DC')
        if ret == -1:
            return ret

        # configure smb.conf
        print('Configuring smb.conf...')
        config_smb_conf(creds, args.domain, server=True)

        # configure pam_winbind.conf
        print('Configuring pam_winbind.conf...')
        config_winbind_conf()

        # start samba
        sys.stdout.write('Starting samba... ')
        ret = start_samba()
        if ret != 0:
            sys.stdout.write('failed\n')
        else:
            sys.stdout.write('ok\n')

        # make sure the A record was added 
        dns_add = SambaToolFactory(cmd_add_record, args, creds)
        for ip in ip_addrs():
            print('Verifying the DC DNS Record...')
            cmd = ['host', '-t', 'A', hostname[0]]
            if debug_level != '0':
                print(' '.join(cmd))
            ret = Popen(cmd, stdout=PIPE, stderr=PIPE).wait()
            if ret != 0:
                sys.stdout.write('Creating the DC DNS Record... ')
                dns_add.run(server, args.domain, hostname[1], 'A', ip)

        print('Verifying the objectGUID Record...')
        sleep(3) # Creating the objectGUID dies if we don't sleep a bit
        objectGUID = None
        l = ldap_open(args.domain, creds)
        results = l.search_s("CN=Sites,CN=Configuration,%s" % realm_to_dn(args.domain), ldap.SCOPE_SUBTREE, "(invocationId=*)", ["objectguid"])
        for result in results:
            if 'CN=NTDS Settings,CN=%s,' % hostname[1] in result[0]:
                objectGUID = str(uuid.UUID(bytes=result[1]['objectGUID'][-1]))
                break
        if objectGUID:
            cmd = ['host', '-t', 'CNAME', '%s._msdcs.%s' % (objectGUID, args.domain)]
            if debug_level != '0':
                print(' '.join(cmd))
            ret = Popen(cmd).wait()
            if ret != 0:
                sys.stdout.write('Creating the objectGUID Record... ')
                dns_add.run(hostname[1], '_msdcs.%s' % args.domain,
                            objectGUID, 'CNAME', hostname[0])

    # configure nss
    print('Configuring nsswitch.conf...')
    configure_nss()

    # configure pam
    print('Configuring pam...')
    configure_pam()

def provision(args):
    if getuser() != 'root':
        sys.stderr.write('ads provision must be run as root\n')
        sys.exit(1)

    stop_samba()
    stop_disable_service('nscd')

    # Update hostname
    print('Updating hostname...')
    hostname = update_hostname(args.host_name, args.domain)

    stash_config()
    clean_samba_db()

    print('Provision the domain controller...')
    provision = SambaToolFactory(cmd_domain_provision, args)
    provision.set_realm(args.domain.upper())
    ret = provision.run(interactive=args.interactive, domain=args.domain,
                        domainguid=args.domain_guid, domainsid=args.domain_sid,
                        hostname=args.host_name,
                        hostip=args.host_ip, hostip6=args.host_ip6,
                        sitename=args.site, ntdsguid=args.ntds_guid,
                        invocationid=args.invocationid,
                        adminpass=args.adminpass,
                        krbtgtpass=args.krbtgtpass,
                        dns_backend=args.dns_backend,
                        dnspass=args.dnspass, root=args.root,
                        nobody=args.nobody, users=args.users, blank=args.blank,
                        serverrole=args.server_role,
                        function_level=args.function_level,
                        next_rid=args.next_rid,
                        partitions_only=args.partitions_only,
                        use_rfc2307=args.use_rfc2307)
    if ret == -1:
        return ret

    # configure smb.conf
    print('Configuring smb.conf...')
    config_smb_conf(creds, args.domain, server=True)

    # configure pam_winbind.conf
    print('Configuring pam_winbind.conf...')
    config_winbind_conf()

    print('Configuring kerberos...')
    lp = LoadParm()
    lp.load_default()
    cmd = ['ln', '-sf', os.path.join(lp.get('private directory'), 'krb5.conf'), krb5_conf]
    if debug_level != '0':
        print(' '.join(cmd))
    Popen(cmd).wait()

    # start samba
    sys.stdout.write('Starting samba... ')
    ret = start_samba()
    if ret != 0:
        sys.stdout.write('failed\n')
    else:
        sys.stdout.write('ok\n')

    # configure nss
    print('Configuring nsswitch.conf...')
    configure_nss()

    # configure pam
    print('Configuring pam...')
    configure_pam()

def demote(args):
    global debug_level, samba_tool, krb5_conf
    if getuser() != 'root':
        sys.stderr.write('ads demote must be run as root\n')
        sys.exit(1)
    creds = get_creds(args)

    print('Demoting the ADDC...')
    cmd = [samba_tool, 'domain', 'demote', '-d', debug_level, '-U%s%%%s' % (creds.get_username(), creds.get_password())]
    if debug_level != '0':
        print(' '.join(cmd[:-1]), '-U%s' % admin)
    Popen(cmd).wait()

    lp = LoadParm()
    lp.load_default()
    print('Unmounting the sysvol...')
    Popen(['umount', lp.get('path', 'sysvol')]).wait()

    print('Disabling the samba service...')
    stop_disable_service('samba')
    stop_samba()

    print('Unconfiguring pam...')
    unconfigure_pam()

    print('Unconfiguring nss...')
    unconfigure_nss()

    # Cleanup old samba database files
    print('Deleting samba database files...')
    clean_samba_db()

    if os.path.exists(default_path()):
        print('Deleting smb.conf...')
        os.remove(default_path())
    if os.path.exists(krb5_conf):
        print('Deleting krb5.conf...')
        os.remove(krb5_conf)


def unjoin(args):
    global debug_level, net, krb5_conf
    lp = LoadParm()
    lp.load_default()
    if lp.get('server role') == 'active directory domain controller':
        demote(args)
    else:
        if getuser() != 'root':
            sys.stderr.write('ads unjoin must be run as root\n')
            sys.exit(1)
        creds = get_creds(args)

        print('Unjoining the domain...')
        cmd = [net, 'ads', 'leave', '-d', debug_level, '-U%s%%%s' % (creds.get_username(), creds.get_password())]
        if debug_level != '0':
            print(' '.join(cmd[:-1]), '-U%s' % admin)
        Popen(cmd).wait()

        remove_hosts_config()

        stop_disable_service('winbindd')

        stop_samba()

        print('Unconfiguring pam...')
        unconfigure_pam()

        print('Unconfiguring nss...')
        unconfigure_nss()

        # Cleanup old samba database files
        clean_samba_db()

        if os.path.exists(default_path()):
            print('Deleting smb.conf...')
            os.remove(default_path())
        if os.path.exists(krb5_conf):
            print('Deleting krb5.conf...')
            os.remove(krb5_conf)

def info_domain(args):
    print(get_default_realm())

def info_cldap(args):
    creds = get_creds(args)
    lp = LoadParm()
    lp.load_default()

    netcmd = Net(creds, lp)
    cldap_ret = netcmd.finddc(address=args.server, flags=(nbt.NBT_SERVER_LDAP | nbt.NBT_SERVER_DS))
    print('DomainGuid:\t\t%s' % cldap_ret.domain_uuid)
    print('DnsForestName:\t\t%s' % cldap_ret.forest)
    print('DnsDomainName:\t\t%s' % cldap_ret.dns_domain)
    print('DnsHostName:\t\t%s' % cldap_ret.pdc_dns_name)
    print('NetbiosDomainName:\t%s' % cldap_ret.domain_name)
    print('NetbiosComputerName:\t%s' % cldap_ret.pdc_name)
    print('UserName:\t\t%s' % cldap_ret.user_name)
    print('DcSiteName:\t\t%s' % cldap_ret.server_site)
    print('ClientSiteName:\t\t%s' % cldap_ret.client_site)

def kcc_cmd(name):
    path = which(name)
    if not path:
        try:
            out, _ = Popen(['rpm', '-ql', 'krb5-client'], stderr=open(os.devnull, 'w'), stdout=PIPE).communicate()
            files = out.decode().split()
            for f in files:
                if os.path.split(f)[-1] == name:
                    return f
        except OSError:
            pass
    else:
        return path
    return name

def kcc(cmd):
    if debug_level != '0':
        print(' '.join(cmd))
    try:
        return Popen(cmd).wait()
    except OSError as e:
        if 'No such file or directory' in str(e):
            sys.stderr.write('%s is not in your path\n' % cmd[0])
            sys.exit(1)

def kinit(args):
    cmd = [kcc_cmd('kinit')]
    cmd.extend(args)
    kcc(cmd)

def klist(args):
    cmd = [kcc_cmd('klist')]
    cmd.extend(args)
    kcc(cmd)

def kdestroy(args):
    cmd = [kcc_cmd('kdestroy')]
    cmd.extend(args)
    kcc(cmd)

def ktutil(args):
    cmd = [kcc_cmd('ktutil')]
    cmd.extend(args)
    kcc(cmd)

def flush(args):
    if getuser() != 'root':
        sys.stderr.write('ads flush must be run as root\n')
        sys.exit(1)
    stop_samba()

    lp = LoadParm()
    lp.load_default()
    gencache = tdb.open(lp.state_path('lock/gencache.tdb'), tdb_flags=tdb.NOLOCK)
    gencache.clear()

    if lp.get('server role') == 'active directory domain controller':
        start_samba()
    else:
        start_enable_service('winbindd', winbindd)

def daemon(args):
    if getuser() != 'root':
        sys.stderr.write('ads daemon must be run as root\n')
        sys.exit(1)
    binary = None
    if args.service == 'winbindd':
        binary = winbindd
    elif args.service == 'samba':
        binary = samba
    if args.action == 'start':
        return start_enable_service(args.service, binary)
    elif args.action == 'stop':
        stop_samba(args.service)
    elif args.action == 'restart':
        stop_samba(args.service)
        return start_enable_service(args.service, binary)

def argparse_add_options(parser, options, ignore=[]):
    '''Add samba options to an argparse parser
    param parser    The parser to append arguments to
    param options   A list of Option objects to modify and add as arguments
    '''
    for opt in options:
        if opt.dest in ignore:
            continue
        kwargs = {}
        if opt.action is not None:
            kwargs['action'] = opt.action
        if opt.type is not None:
            if opt.type == 'string':
                kwargs['type'] = str
            elif opt.type == 'choice':
                pass
            else:
                exec("kwargs['type'] = %s" % opt.type)
        if opt.dest is not None:
            kwargs['dest'] = opt.dest
        if opt.default is not None and opt.default != ('NO', 'DEFAULT'):
            kwargs['default'] = opt.default
        if opt.nargs is not None:
            kwargs['nargs'] = opt.nargs
        if opt.const is not None:
            kwargs['const'] = opt.const
        if opt.choices is not None:
            kwargs['choices'] = opt.choices
        if opt.help is not None:
            kwargs['help'] = opt.help
        if opt.metavar is not None:
            kwargs['metavar'] = opt.metavar
        parser.add_argument(opt.get_opt_string(), **kwargs)

def argparser():
    description = "Active Directory Swiss army knife for samba.\nFor join, unjoin, provisioning, demotion, user/group and password administration,\nldap attribute modification, posix enablement, kdc timesync, pam and nss configuration,\ndaemon start/stop, cache flush, etc.\nThe ads command attempts to maintain compatibility with the proprietary vastool command,\nwhile also adding additional features relevant to samba (such as kdc provisioning)."
    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-v', '--version', action='version', version='@VERSION@', help='ads version')
    parser.add_argument('--pam_auth_conf', help='Specify the location of the pam auth conf file')
    parser.add_argument('--pam_password_conf', help='Specify the location of the pam password file')
    parser.add_argument('-u', help='Authenticating user')
    parser.add_argument('-w', help='Authenticating password')
    parser.add_argument('-d', help='debug level')
    subparsers = parser.add_subparsers()

    nss_parser = subparsers.add_parser('nss', help='Run nss functions')
    nss_subparsers = nss_parser.add_subparsers()
    getpwnam_parser = nss_subparsers.add_parser('getpwnam')
    getpwnam_parser.add_argument('object', help='username')
    getpwnam_parser.add_argument('-d', '--direct', help='bypass the nss layer and return results directly from ldap', action='store_true')
    getpwnam_parser.set_defaults(func=nss_getpwnam)
    getpwuid_parser = nss_subparsers.add_parser('getpwuid')
    getpwuid_parser.add_argument('object', help='uid')
    getpwuid_parser.set_defaults(func=nss_getpwuid)
    getgrnam_parser = nss_subparsers.add_parser('getgrnam')
    getgrnam_parser.add_argument('object', help='groupname')
    getgrnam_parser.set_defaults(func=nss_getgrnam_getgrid)
    getgrid_parser = nss_subparsers.add_parser('getgrid')
    getgrid_parser.add_argument('object', help='gid')
    getgrid_parser.set_defaults(func=nss_getgrnam_getgrid)
    getpwent_parser = nss_subparsers.add_parser('getpwent')
    getpwent_parser.add_argument('-d', '--direct', help='bypass the nss layer and return results directly from ldap', action='store_true')
    getpwent_parser.set_defaults(func=nss_getpwent)
    getgrent_parser = nss_subparsers.add_parser('getgrent')
    getgrent_parser.set_defaults(func=nss_getgrent)
    nss_parser.set_defaults(func=lambda args: args.help_func())
    nss_parser.set_defaults(help_func=nss_parser.print_help)

    user_parser = subparsers.add_parser('user', help='Manage Active Directory users')
    user_subparsers = user_parser.add_subparsers()
    checklogin_parser = user_subparsers.add_parser('checklogin')
    checklogin_parser.add_argument('user')
    checklogin_parser.set_defaults(func=user_checklogin)
    user_parser.set_defaults(func=lambda args: args.help_func())
    user_parser.set_defaults(help_func=user_parser.print_help)

    create_parser = subparsers.add_parser('create', help='Create Active Directory users/groups')
    create_parser.add_argument('-e', help='Operate on an existing object', action='store_true')
    create_parser.add_argument('-i', help='Passwd line for unix enable')
    create_parser.add_argument('-c', help='Container to create object in')
    create_subparsers = create_parser.add_subparsers()
    create_user_parser = create_subparsers.add_parser('user')
    create_user_parser.add_argument('object', help='user')
    create_user_parser.set_defaults(func=create_user)
    create_group_parser = create_subparsers.add_parser('group')
    create_group_parser.add_argument('object', help='group')
    create_group_parser.set_defaults(func=create_group)
    create_parser.set_defaults(func=lambda args: args.help_func())
    create_parser.set_defaults(help_func=create_parser.print_help)

    delete_parser = subparsers.add_parser('delete', help='Delete Active Directory users/groups')
    delete_subparsers = delete_parser.add_subparsers()
    delete_user_parser = delete_subparsers.add_parser('user')
    delete_user_parser.add_argument('object', help='user')
    delete_user_parser.set_defaults(func=delete_user)
    delete_group_parser = delete_subparsers.add_parser('group')
    delete_group_parser.add_argument('object', help='group')
    delete_group_parser.set_defaults(func=delete_group)
    delete_parser.set_defaults(func=lambda args: args.help_func())
    delete_parser.set_defaults(help_func=delete_parser.print_help)

    list_parser = subparsers.add_parser('list', help='List Active Directory users/groups')
    list_subparsers = list_parser.add_subparsers()
    list_users_parser = list_subparsers.add_parser('users')
    list_users_parser.set_defaults(func=nss_getpwent)
    list_groups_parser = list_subparsers.add_parser('groups')
    list_groups_parser.set_defaults(func=nss_getgrent)
    list_parser.set_defaults(func=lambda args: args.help_func())
    list_parser.set_defaults(help_func=list_parser.print_help)

    passwd_parser = subparsers.add_parser('passwd', help='Change Active Directory user passwords')
    passwd_parser.add_argument('-r', help='Sets the password to a random value')
    passwd_parser.add_argument('-o', help='Will output the new password to stdout')
    passwd_parser.add_argument('object', nargs='?')
    passwd_parser.set_defaults(func=passwd)
    passwd_parser.set_defaults(help_func=passwd_parser.print_help)

    attrs_parser = subparsers.add_parser('attrs', help='List Active Directory object attributes')
    attrs_parser.add_argument('-b', action='store_true', help='Convert sid to human readable form')
    attrs_parser.add_argument('-c', help='Container to search in')
    attrs_parser.add_argument('-g', help='Treat the object as a group name', action='store_true')
    attrs_parser.add_argument('object')
    attrs_parser.add_argument('attributes', nargs='*')
    attrs_parser.set_defaults(func=attrs)
    attrs_parser.set_defaults(help_func=attrs_parser.print_help)

    setattrs_parser = subparsers.add_parser('setattrs', help='Modify Active Directory object attributes')
    setattrs_parser.add_argument('object', help='distinguishedName')
    setattrs_parser.add_argument('attribute')
    setattrs_parser.add_argument('value')
    setattrs_parser.set_defaults(func=setattrs)
    setattrs_parser.set_defaults(help_func=setattrs_parser.print_help)

    join_parser = subparsers.add_parser('join', help='Join this computer to an Active Directory domain')
    join_parser.add_argument('--autogen-posix-attrs', action='store_true')
    join_parser.add_argument('--domain-controller', action='store_true', help='Join the machine as a Active Directory Domain Controller member server')
    join_parser.add_argument('--disable-pam', action='store_true', help='Don\'t configure pam during the join')
    join_parser.add_argument('domain')
    join_parser.add_argument('-n', help='Join as hostname')
    join_parser.add_argument('servers', nargs='*')
    join_parser.set_defaults(func=join)
    join_parser.set_defaults(help_func=join_parser.print_help)

    unjoin_parser = subparsers.add_parser('unjoin', help='Unjoin this computer from the Active Directory domain')
    unjoin_parser.set_defaults(func=unjoin)
    unjoin_parser.set_defaults(help_func=unjoin_parser.print_help)

    provision_parser = subparsers.add_parser('provision', help='Provision an Active Directory Domain Controller')
    provision_parser.add_argument('domain', help='NetBIOS domain name to use')
    argparse_add_options(provision_parser, cmd_domain_provision.takes_options, ['domain'])
    provision_parser.set_defaults(func=provision)
    provision_parser.set_defaults(help_func=provision_parser.print_help)

    demote_parser = subparsers.add_parser('demote', help='Demote an Active Directory Domain Controller')
    demote_parser.set_defaults(func=demote)
    demote_parser.set_defaults(help_func=demote_parser.print_help)

    timesync_parser = subparsers.add_parser('timesync', help='Syncronize machine time with Active Directory')
    timesync_parser.add_argument('-s', help='Server to sync with')
    timesync_parser.set_defaults(func=timesync)
    timesync_parser.set_defaults(help_func=timesync_parser.print_help)

    configure_parser = subparsers.add_parser('configure', help='Configure pam and nss for winbind authentication')
    configure_subparsers = configure_parser.add_subparsers()
    configure_pam_parser = configure_subparsers.add_parser('pam')
    configure_pam_parser.set_defaults(func=configure_pam)
    configure_nss_parser = configure_subparsers.add_parser('nss')
    configure_nss_parser.set_defaults(func=configure_nss)
    configure_parser.set_defaults(func=configure)
    configure_parser.set_defaults(help_func=configure_parser.print_help)

    unconfigure_parser = subparsers.add_parser('unconfigure', help='Unconfigure pam and nss for winbind authentication')
    unconfigure_subparsers = unconfigure_parser.add_subparsers()
    unconfigure_pam_parser = unconfigure_subparsers.add_parser('pam')
    unconfigure_pam_parser.set_defaults(func=unconfigure_pam)
    unconfigure_nss_parser = unconfigure_subparsers.add_parser('nss')
    unconfigure_nss_parser.set_defaults(func=unconfigure_nss)
    unconfigure_parser.set_defaults(func=unconfigure)
    unconfigure_parser.set_defaults(help_func=unconfigure_parser.print_help)

    info_parser = subparsers.add_parser('info', help='Get information about the domain')
    info_subparsers = info_parser.add_subparsers()
    info_domain_parser = info_subparsers.add_parser('domain')
    info_domain_parser.set_defaults(func=info_domain)
    info_cldap_parser = info_subparsers.add_parser('cldap')
    info_cldap_parser.add_argument('server')
    info_cldap_parser.set_defaults(func=info_cldap)
    info_parser.set_defaults(func=lambda args: args.help_func())
    info_parser.set_defaults(help_func=info_parser.print_help)

    kinit_parser = subparsers.add_parser('kinit', help='Request an initial ticket-granting ticket', add_help=False)
    kinit_parser.set_defaults(func=kinit)

    klist_parser = subparsers.add_parser('klist', help='Lists the Kerberos principal and Kerberos tickets held in a  credentials  cache', add_help=False)
    klist_parser.set_defaults(func=klist)

    kdestroy_parser = subparsers.add_parser('kdestroy', help='Destroys the user\'s active Kerberos authorization tickets', add_help=False)
    kdestroy_parser.set_defaults(func=kdestroy)

    ktutil_parser = subparsers.add_parser('ktutil', help='Invokes a command interface from which an administrator can read, write, or edit entries in a keytab', add_help=False)
    ktutil_parser.set_defaults(func=ktutil)

    flush_parser = subparsers.add_parser('flush', help='Deletes all cache entries')
    flush_parser.set_defaults(func=flush)
    flush_parser.set_defaults(help_func=flush_parser.print_help)

    daemon_parser = subparsers.add_parser('daemon', help='Start, stop or restart the samba or winbind service')
    daemon_parser.add_argument('action', choices=['start', 'stop', 'restart'])
    daemon_parser.add_argument('service', choices=['winbindd', 'samba'])
    daemon_parser.set_defaults(func=daemon)
    daemon_parser.set_defaults(help_func=daemon_parser.print_help)

    return parser

if __name__ == "__main__":
    parser = argparser()
    args, unknownargs = parser.parse_known_args()

    if args.pam_auth_conf:
        pam_auth_conf = args.pam_auth_conf
    if args.pam_password_conf:
        pam_password_conf = args.pam_password_conf

    if args.d:
        debug_level = args.d

    if args.func in [kinit, klist, kdestroy, ktutil]:
        sys.exit(args.func(unknownargs))
    elif len(unknownargs) == 0:
        sys.exit(args.func(args))
    else:
        sys.exit(args.help_func())
